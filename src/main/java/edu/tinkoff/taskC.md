[К оглавлению](https://github.com/Musador13/Tinkoff-Contest/blob/main/README.md)

# Задача C. Лифты и перегородки.

### Ограничение времени

- #### 1 секунда

### Ограничение памяти

- #### 256 МБ

---

Костя подключен к мобильному оператору «Мобайл». Абонентская плата Кости составляет _A_ рублей в месяц. За эту стоимость
Костя получает _B_ мегабайт интернет-трафика. Если Костя выйдет за лимит трафика, то каждый следующий мегабайт будет
стоить ему _C_ рублей. Костя планирует потратить _D_ мегабайт интернет-трафика в следующий месяц. Помогите ему
сосчитать, во сколько рублей ему обойдется интернет.

#### Формат входных данных
Вводится _4_ целых положительных числа _A,B,C,D(1≤A,B,C,D≤100)_ — стоимость
тарифа Кости, размер тарифа Кости, стоимость каждого лишнего мегабайта, размер интернет-трафика Кости в следующем
месяце. Числа во входном файле разделены пробелами.


#### Формат выходных данных
Выведите одно натуральное число — суммарные расходы Кости на интернет.


#### Замечание
В первом примере Костя сначала оплатит пакет интернета, после чего потратит на _55_ мегабайт больше, чем разрешено по
тарифу. Следовательно, за 55 мегабайт он дополняет отдельно, получившаяся стоимость
_100+12×5=160_ рублей.<br>
Во втором примере Костя укладывается в тарифный план, поэтому платит только за него.

## Примеры данных

### Пример 1

**Ввод**<br>
100 10 12 15<br>

**Вывод**<br>
160

### Пример 2

**Ввод**<br>
100 10 12 1<br>

**Вывод**<br>
100<br>

---

# **Решение**
````java
import java.util.Arrays;
import java.util.Scanner;

/**
 * Задача C. Лифты и переговорки.
 */
public class Exercise3 {

    public static void main(String[] args) {

        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt();
        int t = scanner.nextInt();
        int[] floors = new int[n];

        for (int i = 0; i < n; i++) {
            floors[i] = scanner.nextInt();
        }
        int k = scanner.nextInt();
        scanner.close();

        int max = Arrays.stream(floors).reduce(Integer::max).getAsInt();
        int min = Arrays.stream(floors).reduce(Integer::min).getAsInt();
        int dif = max - min;
        int res;

        int maxX = max - t;
        int minX = t + min;
        int x = floors[k - 1];

        if (minX >= x || maxX <= x) {
            res = max - min;
        } else {
            int toUp = dif + max - x;
            int toDown = dif + x - min;
            res = Math.min(toDown, toUp);
        }
        System.out.println(res);
    }
}
